# Writing Project Management Tool

Scaffold for the writing project management tool. Features planned:

- Boards, lists, and cards
- Card editor with markdown support
- Autosave & localStorage
- Filters, tags, and sorting

Open `index.html` to view the prototype.

What did you build and why?
For this project, I built a Writing Project Tool that treats each writing project as a “board” with To Do, Doing, and Done columns. Each board holds task cards (like drafting a scene, revising a chapter, or writing character backstory), and I added features for sprints, characters, and tracking total word count across projects. I wanted something that reflected how I actually write: juggling multiple projects, jumping between tasks, and trying to keep characters, drafts, and progress organized in one place. Instead of just task app, this is tailored to writers—especially people like me who are balancing school, creative work, and deadlines and need a space that “gets” that chaos.

What skills from Projects 1–3 did you upskill? How?
Even though this app feels very different from my earlier projects, it’s really built on top of them. From Project 1, I brought forward my understanding of basic HTML structure and how to keep things readable and organized in the DOM. From Project 2, I expanded my use of lists, dynamic elements, and input handling—this time with task cards that move between columns and attach to boards instead of just a simple tracker. From Project 3, I went deeper into JavaScript logic: selecting the right elements, updating the UI when data changes, and keeping different parts of the app in sync (boards, tasks, sprints, characters, and progress). I also unintentionally upskilled my debugging skills. Any time a column stopped rendering or a button stopped working, I had to trace the problem backward through event listeners, data structures, and DOM updates instead of just starting over.

How did AI change your development process?
AI changed my development process in both helpful and frustrating ways. On the helpful side, it made it easier to think bigger about what my app could do. It helped me sketch out features like linking characters to boards or attaching sprints to either a project or an individual task. It also explained concepts in plain language when I needed to understand why my code behaved a certain way.
On the frustrating side, AI was almost too eager to help. It often removed or rewrote large chunks of code when I only wanted a small fix. It would forget the basics of my existing structure and jump straight into more complex patterns that didn’t fit what I had already built. A lot of my time was spent undoing changes, re-adding logic that got deleted, and reminding it of how my app was actually supposed to work. That forced me to be much more protective and intentional about my code—I had to know it well enough to tell when AI was making it better and when it was just overcomplicating things.

What surprised you about working with AI?
I was surprised by how unreliable AI could be in the middle of a project. I expected it to occasionally be wrong, but I didn’t expect it to forget what we’d already built together or to keep “helping” by throwing out my existing patterns and replacing them with something new and more complex. It sometimes felt like working with someone who skimmed the assignment and then tried to refactor the whole app instead of solving the small, specific problem I asked about. At the same time, I was surprised by how much I learned from that. When I pushed back and asked AI to slow down, focus on one bug, or explain a concept instead of rewriting everything, the answers were actually useful and made me more confident in reading and editing my own code.

What would you do differently next time?
Next time, I would be much stricter about how I use AI. I’d start by asking for conceptual help first (“Explain how to structure this” or “What’s the best way to move cards between columns?”) before giving it my actual code. I’d also copy my current file into a safe version before pasting anything new in, so I have something to roll back to if the AI solution deletes or breaks core logic. I’d be clearer with my prompts—explicitly saying “Do not remove any existing functions” or “Only modify this one section.” Overall, I’d treat AI more like a reference and less like a co-author of the code.

How has your confidence as a developer changed?
Even with all the headaches, I do feel more confident after this project. Building the Writing Project Tool pushed me past following step-by-step labs and into actually making something that didn’t exist before. Working with AI forced me to read my own code more carefully, understand it line by line, and make decisions about what to keep and what to reject. I’m more comfortable now with messy in-between stages, with debugging, and with the idea that I can shape an app around how I work, not just how the example looks. I still don’t feel like a “perfect” developer, but I do feel like someone who can read, reason through, and defend my own code—and that’s a big shift.

